Алгоритм это набор последовательных действий которые решают определенную задачу.

Алгортмы:
  - Поиска
  - Сортировки
  - Рекурсивные
  - Дейкстры для поиска кратчайшего пути в графе
  - Обхода деревье
  - Кеширования


Структуры
  - массивы
  - связный список
  - очередь
  - стек
  - сет
  - мэп
  - двоичное дерево
  - n-арное дерево
  - графы


    АЛГОРИТМЫ
Виды алгоритмов 
O(Log2n) - Бинарные
O(n) - Линейные
O(n * log2n) - 
O(n!) - Факторял

O - о большое 
n - количество операции

Сложность алгоритма мериться по количеству операции


 ПОИСК
Линейный поиск  O(n)
Он работает от начало до конца и смотрит все до конца

Бинарный поиск  O(Log2n)
Он начинает с середины например: 
Если от 1 до 10 массив, скажем мы выбрали 3, он сначала смотрит на 5, сравняет item с значением, item меньше значит он смотрит на 2, item больше и таким образом находит


  СОРТИРОВКА
Сортировка с выбором  O(0.5*n*n)  (array.length = 15, 105-итораций)
Например у нас есть массив [6, 4, 3, 1, 7, 8, 4, 4, 3, 9] мы ищем самую маленькую число, у нас тут 1, потом мы его сравниваем с первым элементом, у нас тут 6, если первый элемент больше чем самый маленький элемент, то их меняем местами. И так пока полностью массив не отсортируем

Позырьковая сортировка   O(n*n) (array.length = 15, 225-итораций)
Это один из самых известных алгоритмов, и один из самых не эффективных. скажем что у нас есть массив [6, 4, 3, 1, 7, 8, 4, 4, 3, 9] мы берем первую значению (6) меняем местами со второй (4)

Быстрая сортировка (Сортировка Хоара) O(log*n) (array.length = 15, 53-итораций)
Каждый раз как бинарный поиск, мы выбираем средный значение рекурсивно. Потом все элементы который меньше выбранного мы добавляем в другой массив, все больше в друг. И для каждого из этих массивов выполняется такая же операция. И так делается до тех пор, пока длина массива не станет равно единиций. И в конце, все эти массивы склеиваются в один большой


  РЕКУРСИЯ
Что такое рукерсия?
  Рекурсия - это функция которая вызывает сама себя.


  ГРАФИКИ
Что такое граф?
  Граф это некое абстрактная структура данных, представляющая со бой множество вершин и набор ребер (то есть соединений между парами ребер). Самый простой наглядный пример графа, это карта. На которой есть города, и города соединений маршрутами. Маршуруты в данном случае, это ребра, а города вершины
     B.______________.F
     /              /|\
  А./            D./ | \.G
    \             /  |
     \.C_______H./___|.E
  Все эти точки вершины, а линий это ребра.
  Ребра бывают однонаправленными и двунаправленными. В нашем случае мы считаем что, это однонаправленный. Из А мы идем к G. Кратчайший пример (A, B, F, G)

  ДЕЙСКТРЫ ДЛЯ ПОИСКА КРАТЧАЙШЕГО ПУТИ В ГРАФЕ
     B.______7_______.F
    2/             2/|\1
  А./            D./ | \.G
   1\            5/  |2
     \.C___2___H./__1|.E
  В верхном примере мы доходили от точки А до точки G (A, B, F, G), Но если подсчитать то таким путем мы должны будем пройти 10 единиц. В алгоритме дейкстри мы научимся, доходить минимальным действием. 


  ОБХОДА ДЕРЕВЬЕВ
                                        .
    5                       6                       1                     8

    5                     5 5 5                    5  5                   5

5       5                                                                 5 

Пример с дереьвями . это дерево, а под ним 5, 6, 1, 8 это тоже деревья, только для . они под дереви.
Скажем что у нас есть такое дерево, надо обойти каждый узел, и посчитать сумму значений, который хранит каждый из этих узлов


  КЕШИРОВАНИЕ
Представим что у нас есть какой-то математический задача, который программа будет выполнять с одним значением несколько раз. Так вот чтобы функция каждый раз не сгенерировал одну и ту же операцию, мы можем создать кеш, который будет запоминать первую операцию, и в остальних операциях, он будет возвращать этот ответ.



    СТРУКТУРЫ
  ОЧЕРЕДЬ FIFO (First In Firts Out)
Очередь это массив точно так как в кассе или в аптеке, тот кто пришел первым берет, и уходит первым.


  СТЕК
Стек очень похож на массив но работает совсем наоброт. Тот кто пришел первым, уходит последним


  МАССИВЫ
массивы мы знаем


  СВЯЗНЫЙ СПИСОК
Связный список, это каждый предвидущий элемент, хранит ссылку на следующий элемент списка. Плюс в этом том, что мы можем мгновенно добавлять начало или конец списка элемент.


  БИНАРНОЕ ДЕРЕВО ПОИСКА
                5
    3                       6

  1   5                   5   9

Бинарное дерево, это дерево который строится оссобым способом. Если значение под дерево, меньше чем значение дерево, тогда он уходит в левый угол, если больше то правый.


  МЭП
Мэп это обычный объект который мы ползуемся.
const map = new Map();
map.set('name', 'Dovlet);
console.log(map.get('name'))      // Dovlet

  СЕТ
Сет это тоже массив, который хранит только уникальные значение, дублированные значение он не хранит.
const set = new Set()
set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(4)
set.add(3)
set.add(5)
console.log(set)        // 5, 4, 3