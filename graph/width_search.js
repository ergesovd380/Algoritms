/*
  Поиск в Ширину

     B.______________.F
     /              /|\
  А./            D./ | \.G
    \             /  |
     \.C_______H./___|.E

  Есьт вот такой граф, наша задача, из А за минимальный шаг дойти до G
*/
const graph = {};                            // Создаем переменное с объектом
graph.a = ['b', 'c'];                        // И на него ставим все вершины, с ихними путьями, добавляя в массив (Например: А имеет путь в B, C)
graph.b = ['f'];                             // Имеет путь F
graph.c = ['h'];
graph.h = ['d', 'e'];
graph.d = ['f'];
graph.e = ['f'];
graph.f = ['g'];

function breadthSearch(graph, start, end) {       // Создаем функцию, принимаем туда граф, начальную точку и конечную точку
  let queue = [];                                 // Создаем переменное очередь
  queue.push(start);                              // принимаем в себя стартовую точку
  while(queue.length > 0) {                       // цикл будет повторятся пока очередь не будет пустым
    const current = queue.shift()                 // С помощью метода shift() убераем первую значению из массива (Например в первом случае b, потом c)
    console.log(current);
    console.log(graph[current]);                  // Смотрим куда имеет путь эта вершина, первом случае ['b', 'c']
    if(!graph[current]) {                         // Если у этой вершины нет пути, он вазвращает пустой массив    
      graph[current] = [];                        // Это понадобиться чтобы в конце закончить цикл
    }
    if(graph[current].includes(end)) {            // Смотрим куда имеет путь эта вершина, если он имеет путь в конечную точку
      return true;                                // Тогда возвращаем true
    } else {
      queue = [...queue, ...graph[current]];      // Если нет, тогда в переменную очередь, принимаем остаток переменого, и значение этого графа
      console.log(queue);
    }
  }
  return false;
}

console.log(breadthSearch(graph, 'a', 'g'))